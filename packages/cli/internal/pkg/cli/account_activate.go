// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0

package cli

import (
	"encoding/json"
	"errors"
	"fmt"
	"path/filepath"
	"strings"

	"github.com/aws/amazon-genomics-cli/internal/pkg/aws"
	"github.com/aws/amazon-genomics-cli/internal/pkg/aws/cdk"
	"github.com/aws/amazon-genomics-cli/internal/pkg/aws/cfn"
	"github.com/aws/amazon-genomics-cli/internal/pkg/aws/ecr"
	"github.com/aws/amazon-genomics-cli/internal/pkg/aws/s3"
	"github.com/aws/amazon-genomics-cli/internal/pkg/aws/sts"
	"github.com/aws/amazon-genomics-cli/internal/pkg/cli/awsresources"
	"github.com/aws/amazon-genomics-cli/internal/pkg/cli/clierror"
	"github.com/aws/amazon-genomics-cli/internal/pkg/cli/clierror/actionableerror"
	"github.com/aws/amazon-genomics-cli/internal/pkg/constants"
	"github.com/aws/amazon-genomics-cli/internal/pkg/logging"
	"github.com/aws/amazon-genomics-cli/internal/pkg/osutils"
	"github.com/aws/amazon-genomics-cli/internal/pkg/version"
	"github.com/rs/zerolog/log"
	"github.com/spf13/cobra"
)

const (
	accountBucketFlag            = "bucket"
	accountVpcFlag               = "vpc"
	publicSubnetsFlag            = "usePublicSubnets"
	subnetsFlag                  = "subnets"
	accountTagsFlag              = "tags"
	accountBucketFlagDescription = `The name of an S3 bucket that AGC will use to store its data.
An autogenerated name will be used if not specified. A new bucket will be created if the bucket does not exist.`
	accountVpcFlagDescription = `The ID of a VPC that AGC will run in. 
A new VPC will be created if not specified.`
	publicSubnetsFlagDescription = `Do not create a NAT gateway or VPC endpoints, to lower operating costs. 
You must enable the usePublicSubnets option in your project context if you use this flag.`
	accountTagsDescription = `A list of comma separated tags to be applied to all AGC resources in this account
(i.e. --tags "k1=v1","k2=v2"). Each key-value pair must be quoted as shown in the example,
otherwise the parsing will fail.`
	subnetFlagDescription = `The list of private subnet IDs to use when specifying a VPC to run in. May only be used with the 
'--vpc' flag. If not supplied then all private subnets of a VPC will be used as possible targets of compute infrastructure.
Each subnet must have access to AWS service endpoints e.g. using VPC Gateway Endpoints or via a route to the public internet.
Subnet names may be a comma separated list or supplied as repeated flags.`
	cdkCoreDir   = ".agc/cdk/apps/core"
	bucketPrefix = "agc"
	activateKey  = "activate"
	bootstrapKey = "bootstrap"
)

type accountActivateVars struct {
	bucketName    string
	vpcId         string
	publicSubnets bool
	customTags    map[string]string
	subnets       []string
}

type accountActivateOpts struct {
	accountActivateVars
	stsClient sts.Interface
	s3Client  s3.Interface
	cdkClient cdk.Interface
	ecrClient ecr.Interface
	cfnClient cfn.Interface
	imageRefs map[string]ecr.ImageReference
	region    string
}

func newAccountActivateOpts(vars accountActivateVars) (*accountActivateOpts, error) {
	return &accountActivateOpts{
		accountActivateVars: vars,
		stsClient:           aws.StsClient(profile),
		s3Client:            aws.S3Client(profile),
		cdkClient:           cdk.NewClient(profile),
		cfnClient:           aws.CfnClient(profile),
		region:              aws.Region(profile),
	}, nil
}

// Execute activates AGC.
func (o *accountActivateOpts) Execute() error {

	environmentVars, err := o.generateEnvVars()
	if err != nil {
		return err
	}

	homeDir, err := osutils.DetermineHomeDir()
	if err != nil {
		return err
	}

	cdkAppPath := filepath.Join(homeDir, cdkCoreDir)
	err = o.cdkBootstrap(cdkAppPath, environmentVars)
	if err != nil {
		return err
	}

	return o.deployCoreInfrastructure(cdkAppPath, environmentVars)
}

func (o accountActivateOpts) generateDefaultBucket() (string, error) {
	account, err := o.stsClient.GetAccount()
	if err != nil {
		return "", err
	}
	return generateBucketName(account, o.region), nil
}

func (o accountActivateOpts) generateEnvVars() ([]string, error) {
	if o.bucketName == "" {
		bucketName, err := o.generateDefaultBucket()
		if err != nil {
			return nil, err
		}
		o.bucketName = bucketName
	}

	exists, err := o.s3Client.BucketExists(o.bucketName)
	if err != nil {
		return nil, err
	}

	environmentVars := []string{
		fmt.Sprintf("%s=%t", constants.PublicSubnetsEnvKey, o.publicSubnets),
		fmt.Sprintf("%s=%s", constants.AgcBucketNameEnvKey, o.bucketName),
		fmt.Sprintf("%s=%t", constants.CreateBucketEnvKey, !exists),
		fmt.Sprintf("%s=%s", constants.AgcVersionEnvKey, version.Version),
	}

	if o.customTags != nil {
		jsonBytes, err := json.Marshal(o.customTags)
		if err != nil {
			return nil, err
		}
		environmentVars = append(environmentVars, fmt.Sprintf("%s=%s", constants.CustomTagEnvKey, string(jsonBytes)))
	}

	environmentVars, err = o.appendVpcEnvVars(environmentVars)
	if err != nil {
		return nil, err
	}

	return environmentVars, err
}

func (o accountActivateOpts) appendVpcEnvVars(environmentVars []string) ([]string, error) {
	vpcId, err := o.getVpcId()
	if err != nil {
		return nil, err
	}
	if vpcId != "" {
		environmentVars = append(environmentVars, fmt.Sprintf("VPC_ID=%s", vpcId))
		if o.subnets != nil {
			subnets := strings.Join(o.subnets, ",")
			environmentVars = append(environmentVars, fmt.Sprintf("%s=%s", constants.AgcVpcSubnetsEnvKey, subnets))
		}
	}
	return environmentVars, nil
}

func (o accountActivateOpts) getVpcId() (string, error) {
	if o.vpcId != "" {
		return o.vpcId, nil
	} else {
		coreStackName := awsresources.RenderCoreStackName()
		stackOutputs, err := o.cfnClient.GetStackOutputs(coreStackName)
		if err != nil {
			if errors.Is(err, cfn.StackDoesNotExistError) {
				log.Debug().Msgf("Cloudformation Stack '%s' does not exist", coreStackName)
				return "", nil
			} else {
				return "", err
			}
		}
		if vpcId, ok := stackOutputs["VpcId"]; ok {
			return vpcId, nil
		}
	}
	return "", nil
}

func (o accountActivateOpts) cdkBootstrap(cdkAppPath string, environmentVars []string) error {
	progressStream, err := o.cdkClient.Bootstrap(cdkAppPath, environmentVars, bootstrapKey)
	if err != nil {
		return err
	}
	return displayProgress(progressStream, "Bootstrapping CDK...")
}

func (o accountActivateOpts) deployCoreInfrastructure(cdkAppPath string, environmentVars []string) error {
	progressStream, err := o.cdkClient.DeployApp(cdkAppPath, environmentVars, activateKey)
	if err != nil {
		return err
	}
	return displayProgress(progressStream, "Activating account...")
}

func (o *accountActivateOpts) validate() error {
	if o.publicSubnets && o.vpcId != "" {
		return o.generateValidationError(
			fmt.Errorf("both %[1]q and %[2]q cannot be specified together, as %[2]q involves creating a minimal VPC", accountVpcFlag, publicSubnetsFlag),
			"Remove one or both of these flags")
	}

	if o.subnets != nil && o.vpcId == "" {
		return o.generateValidationError(fmt.Errorf("%q cannot be supplied without supplying a %q ID", subnetsFlag, accountVpcFlag),
			fmt.Sprintf("use the %q flag to supply the identity of the VPC containing the subnets", accountVpcFlag))
	}

	return nil
}

func (o *accountActivateOpts) generateValidationError(cause error, suggestedAction string) error {
	return clierror.New("account activate", o.accountActivateVars, &actionableerror.Error{
		Cause:           cause,
		SuggestedAction: suggestedAction,
	})
}

func displayProgress(progressStream cdk.ProgressStream, displayMsg string) error {
	if logging.Verbose {
		var lastEvent cdk.ProgressEvent
		for event := range progressStream {
			if event.Err != nil {
				for _, line := range lastEvent.Outputs {
					log.Error().Msg(line)
				}
				return event.Err
			}
			lastEvent = event
		}
		log.Debug().Msg(strings.Join(lastEvent.Outputs, "\n"))
	} else {
		return progressStream.DisplayProgress(displayMsg)
	}
	return nil
}

// BuildAccountActivateCommand builds the command for activating AGC in an AWS account.
func BuildAccountActivateCommand() *cobra.Command {
	vars := accountActivateVars{}
	cmd := &cobra.Command{
		Use:   "activate",
		Short: "Activate AGC in an AWS account.",
		Long: `Activate AGC in an AWS account.
AGC will use your default AWS credentials to deploy all AWS resources
it needs to that account and region.`,
		Example: `
Activate AGC in your AWS account with a custom S3 bucket and VPC.
/code $ agc account activate --bucket my-custom-bucket --vpc my-vpc-id`,
		Args: cobra.NoArgs,
		RunE: runCmdE(func(cmd *cobra.Command, args []string) error {
			opts, err := newAccountActivateOpts(vars)
			if err != nil {
				return err
			}
			if err := opts.validate(); err != nil {
				return err
			}
			log.Info().Msgf("Activating AGC with bucket '%s' and VPC '%s'", opts.bucketName, opts.vpcId)
			if err := opts.Execute(); err != nil {
				return clierror.New("account activate", vars, err)
			}
			return nil
		}),
	}
	cmd.Flags().StringVar(&vars.bucketName, accountBucketFlag, "", accountBucketFlagDescription)
	cmd.Flags().StringVar(&vars.vpcId, accountVpcFlag, "", accountVpcFlagDescription)
	cmd.Flags().BoolVar(&vars.publicSubnets, publicSubnetsFlag, false, publicSubnetsFlagDescription)
	cmd.Flags().StringToStringVar(&vars.customTags, accountTagsFlag, nil, accountTagsDescription)
	cmd.Flags().StringSliceVar(&vars.subnets, subnetsFlag, nil, subnetFlagDescription)
	return cmd
}
